<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MD Reader — Leitor de livros Markdown (GitHub)</title>

    <!-- STYLE: visual inspirado na primeira versão (escuro, limpo) -->
    <style>
      :root {
        --bg: #071026;
        --panel: #07162a;
        --muted: #92a4bd;
        --accent: #60a5fa;
        --accent-2: #3b82f6;
        --glass: rgba(255, 255, 255, 0.03);
        --sidebar-width: 300px;
        --radius: 12px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
          Roboto, "Helvetica Neue", Arial;
        background: linear-gradient(180deg, #041025 0%, #061328 60%);
        color: #dff1ff;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 12px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          transparent
        );
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        position: sticky;
        top: 0;
        z-index: 30;
        flex-wrap: wrap;
      }
      .brand {
        font-weight: 700;
        color: var(--accent);
        margin-right: 6px;
        font-size: 18px;
      }
      .input-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex: 1;
        min-width: 200px;
      }
      input[type="text"] {
        flex: 1;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: rgba(255, 255, 255, 0.01);
        color: inherit;
        outline: none;
        min-width: 0;
      }
      .btn {
        padding: 9px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: linear-gradient(180deg, var(--accent), var(--accent-2));
        color: #021025;
        font-weight: 600;
        cursor: pointer;
      }
      .btn.ghost {
        background: transparent;
        color: var(--muted);
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .small {
        padding: 7px 10px;
        font-size: 14px;
        border-radius: 8px;
      }
      .status-line {
        font-size: 13px;
        color: var(--muted);
        margin-left: 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 260px;
      }

      /* Layout */
      .app {
        display: flex;
        flex: 1;
        gap: 12px;
        padding: 12px;
        min-height: 0;
      }

      aside.toc {
        width: var(--sidebar-width);
        max-width: 40%;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.01),
          rgba(255, 255, 255, 0.02)
        );
        border-radius: var(--radius);
        padding: 12px;
        position: relative;
        height: calc(100vh - 104px);
        overflow: auto;
        flex-shrink: 0;
        border: 1px solid rgba(255, 255, 255, 0.03);
        transition: transform 0.22s ease, opacity 0.22s ease;
        z-index: 15;
      }
      aside.toc.hidden {
        transform: translateX(-120%);
        opacity: 0;
        pointer-events: none;
      }
      .toc-top {
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: space-between;
      }
      .toc-top h3 {
        margin: 0;
        font-size: 14px;
        color: var(--muted);
      }
      .toc-actions {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      ul.toc-list {
        list-style: none;
        padding: 8px 0;
        margin: 6px 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      li.toc-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        border-radius: 8px;
        cursor: pointer;
      }
      li.toc-item:hover {
        background: rgba(255, 255, 255, 0.02);
      }
      li.toc-item .title {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      li.toc-item.active {
        background: linear-gradient(
          90deg,
          rgba(96, 165, 250, 0.12),
          rgba(59, 130, 246, 0.06)
        );
        border: 1px solid rgba(96, 165, 250, 0.12);
        font-weight: 700;
        color: var(--accent);
      }
      li.toc-item.read .dot {
        opacity: 0.8;
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.06);
        flex-shrink: 0;
      }

      main.reader {
        flex: 1;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.01),
          transparent
        );
        border-radius: var(--radius);
        padding: 20px;
        height: calc(100vh - 104px);
        overflow: auto;
        border: 1px solid rgba(255, 255, 255, 0.03);
        position: relative;
      }
      .content h1,
      .content h2,
      .content h3 {
        margin-top: 1.2em;
        margin-bottom: 0.6em;
        color: #e6f4ff;
      }
      .content p {
        line-height: 1.7;
        color: #dbeafe;
      }
      .content pre {
        background: #021426;
        padding: 12px;
        border-radius: 8px;
        overflow: auto;
      }
      .content code {
        background: rgba(255, 255, 255, 0.03);
        padding: 2px 6px;
        border-radius: 6px;
      }
      .content img {
        max-width: 100%;
        height: auto;
        border-radius: 6px;
      }
      .content blockquote {
        border-left: 3px solid rgba(96, 165, 250, 0.2);
        padding-left: 12px;
        color: var(--muted);
      }
      .content a {
        color: var(--accent);
        text-decoration: underline;
      }
      .hint {
        font-size: 13px;
        color: var(--muted);
      }

      /* Internal TOC (within chapter) */
      .toc-internal {
        position: sticky;
        top: 12px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.012),
          transparent
        );
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 12px;
        border: 1px solid rgba(255, 255, 255, 0.02);
      }
      .toc-internal ul {
        list-style: none;
        padding-left: 6px;
        margin: 6px 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .toc-internal a {
        color: var(--muted);
        text-decoration: none;
        font-size: 14px;
      }
      .toc-internal a.active {
        color: var(--accent);
        font-weight: 700;
      }

      /* mobile adjustments */
      @media (max-width: 900px) {
        aside.toc {
          position: fixed;
          left: 0;
          top: 72px;
          height: calc(100% - 72px);
          background: rgba(7, 22, 42, 0.98);
          width: 82%;
          max-width: 360px;
          box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
        }
        .app {
          padding: 8px;
        }
        header {
          padding: 8px;
          gap: 8px;
        }
        .status-line {
          display: none;
        }
        /* compress header actions into menu */
        .wide-only {
          display: none;
        }
      }

      @media (max-width: 520px) {
        input[type="text"] {
          min-width: 120px;
        }
        .brand {
          font-size: 15px;
        }
      }

      /* small utility */
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .muted {
        color: var(--muted);
      }
      .icon-btn {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.03);
        padding: 6px;
        border-radius: 8px;
        color: var(--muted);
        cursor: pointer;
      }
      .icon-btn:hover {
        color: var(--accent);
      }
      .pill {
        background: rgba(255, 255, 255, 0.02);
        padding: 6px 8px;
        border-radius: 999px;
        font-size: 13px;
        color: var(--muted);
      }
      .history-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 10px;
      }
      .history-item {
        padding: 8px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.01);
        cursor: pointer;
        font-size: 14px;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }
    </style>

    <!-- Marked + DOMPurify -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  </head>
  <body>
    <header>
      <div style="display: flex; align-items: center; gap: 10px; min-width: 0">
        <div class="brand">MD Reader</div>
        <div class="pill muted wide-only">
          Leitor de livros Markdown (GitHub)
        </div>
      </div>

      <div class="input-row" style="min-width: 0">
        <input
          id="bookUrl"
          type="text"
          placeholder="Cole a URL do README.md no GitHub (ex: https://github.com/.../README.md)"
        />
        <button id="loadBtn" class="btn small">Carregar Livro</button>
      </div>

      <div
        class="controls wide-only"
        style="margin-left: auto; align-items: center"
      >
        <div id="status" class="status-line"></div>
        <button
          id="toggleToc"
          class="icon-btn"
          title="Recolher/Mostrar sumário"
        >
          ≡ Sumário
        </button>
        <button
          id="toggleFullscreenToc"
          class="icon-btn"
          title="Tela cheia (esconder sumário)"
        >
          ⤢
        </button>
        <button
          id="clearBook"
          class="icon-btn"
          title="Limpar memória deste livro"
        >
          🗑
        </button>
        <button id="clearAll" class="icon-btn" title="Limpar memória geral">
          🧹
        </button>
      </div>

      <!-- compact actions for small screens -->
      <div class="wide-only" style="display: none"></div>
      <div style="margin-left: auto" class="compact-actions">
        <button
          id="menuMobile"
          class="icon-btn wide-only"
          style="display: none"
        >
          ⋯
        </button>
      </div>
    </header>

    <div class="app" id="app">
      <aside class="toc" id="tocPane">
        <div class="toc-top">
          <h3>Sumário</h3>
          <div class="toc-actions">
            <button
              id="collapseTocBtn"
              class="icon-btn"
              title="Recolher sumário (mobile)"
            >
              &ndash;
            </button>
            <button
              id="refreshTocBtn"
              class="icon-btn"
              title="Recarregar README"
            >
              ↻
            </button>
          </div>
        </div>

        <div
          id="tocMeta"
          class="muted"
          style="margin-top: 8px; font-size: 13px"
        >
          Cole a URL do README.md e clique em "Carregar Livro".
        </div>

        <ul
          id="tocList"
          class="toc-list"
          aria-live="polite"
          style="margin-top: 10px"
        ></ul>

        <div
          style="
            margin-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.02);
            padding-top: 10px;
            font-size: 13px;
          "
        >
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
            "
          >
            <div class="muted">Capítulos lidos</div>
            <div id="readCount" class="muted">0</div>
          </div>
          <div style="margin-top: 8px" id="historyBrief" class="muted"></div>
        </div>
      </aside>

      <main class="reader" id="reader">
        <div id="content" class="content">
          <p class="hint">
            Bem-vindo! Cole a URL do README.md do livro no GitHub e clique em
            <strong>Carregar Livro</strong>.
          </p>
          <div id="home" style="margin-top: 12px">
            <h3 style="margin-top: 0; color: #cfe8ff">Livros abertos</h3>
            <div id="historyList" class="history-list muted"></div>
          </div>
        </div>
      </main>
    </div>

    <script>
      /* MD Reader — all-in-one SPA (vanilla JS)
   Features:
   - convert GitHub blob URL -> raw.githubusercontent.com
   - parse README.md for TOC links, render sidebar TOC
   - open chapters, convert markdown -> HTML using marked + DOMPurify
   - internal TOC of headings, smooth scroll, highlight current heading (IntersectionObserver)
   - save per-chapter scrollTop in localStorage, restore on load
   - save last opened chapter per-book
   - mark chapters read, show history of opened books
   - clear memory (per-book, all)
   - responsive header and mobile-friendly sidebar with solid background
*/

      (function () {
        // Elements
        const bookUrlInput = document.getElementById("bookUrl");
        const loadBtn = document.getElementById("loadBtn");
        const tocList = document.getElementById("tocList");
        const tocPane = document.getElementById("tocPane");
        const tocMeta = document.getElementById("tocMeta");
        const reader = document.getElementById("reader");
        const contentEl = document.getElementById("content");
        const statusEl = document.getElementById("status");
        const collapseTocBtn = document.getElementById("collapseTocBtn");
        const toggleTocBtn = document.getElementById("toggleToc");
        const toggleFullscreenToc = document.getElementById(
          "toggleFullscreenToc"
        );
        const refreshTocBtn = document.getElementById("refreshTocBtn");
        const clearBookBtn = document.getElementById("clearBook");
        const clearAllBtn = document.getElementById("clearAll");
        const historyList = document.getElementById("historyList");
        const readCountEl = document.getElementById("readCount");
        const historyBrief = document.getElementById("historyBrief");

        // State
        let book = {
          originalUrl: null,
          rawRootUrl: null,
          rawBase: null,
          tocItems: [], // {title, href, rawUrl}
        };
        let activeChapter = null; // {index, title, href, rawUrl}
        let headingObserver = null;
        let currentHeadingId = null;

        // Storage keys
        const KEY_HISTORY = "mdreader:history"; // array of original URLs
        // per-book keys: reading-progress-[book]-[chapter], last-chapter-[book], chapters-read-[book]

        // Utilities
        function setStatus(txt, timeout = 2500) {
          statusEl.textContent = txt || "";
          if (timeout) {
            clearTimeout(setStatus._t);
            setStatus._t = setTimeout(
              () => (statusEl.textContent = ""),
              timeout
            );
          }
        }

        function toRawGithubUrl(inputUrl) {
          // Accept raw or github.com/blob/branch/... forms
          try {
            const trimmed = inputUrl.trim();
            const u = new URL(trimmed);
            if (u.hostname === "raw.githubusercontent.com") return trimmed;
            if (u.hostname === "github.com") {
              const parts = u.pathname.split("/").filter(Boolean);
              // expect: user repo blob branch path...
              if (parts.length >= 4 && parts[2] === "blob") {
                const user = parts[0],
                  repo = parts[1],
                  branch = parts[3];
                const filePath = parts.slice(4).join("/");
                return `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${filePath}`;
              } else {
                throw new Error(
                  "URL inválida: espere /user/repo/blob/branch/path"
                );
              }
            } else {
              throw new Error(
                "Host não suportado. Use github.com ou raw.githubusercontent.com"
              );
            }
          } catch (e) {
            throw new Error("URL inválida");
          }
        }

        function getRawBase(rawFileUrl) {
          const idx = rawFileUrl.lastIndexOf("/");
          return idx === -1 ? rawFileUrl : rawFileUrl.slice(0, idx + 1);
        }

        async function fetchText(url) {
          const resp = await fetch(url);
          if (!resp.ok) throw new Error("Erro fetch " + resp.status);
          return await resp.text();
        }

        function parseTocFromMarkdown(md) {
          // capture common markdown list link patterns
          const regex =
            /(?:^[\s>*-]*)(?:[\*\-\+]\s*)?\[([^\]]+)\]\(([^)]+)\)/gm;
          const items = [];
          let m;
          while ((m = regex.exec(md)) !== null) {
            const title = m[1].trim();
            const href = m[2].trim();
            // ignore anchor-only or external anchors? We'll keep them; build raw later
            items.push({ title, href });
          }
          return items;
        }

        function buildChapterRawUrl(baseRaw, chapterHref) {
          // if chapterHref is absolute URL, try to convert if github.com
          try {
            const u = new URL(chapterHref, baseRaw);
            if (u.hostname === "github.com") return toRawGithubUrl(u.href);
            return u.href;
          } catch (e) {
            // fallback concatenate
            return baseRaw + chapterHref;
          }
        }

        function makeStorageKeyProgress(bookUrl, chapterHref) {
          return `reading-progress-${encodeURIComponent(
            bookUrl
          )}--${encodeURIComponent(chapterHref)}`;
        }
        function makeStorageKeyLastChapter(bookUrl) {
          return `last-chapter-${encodeURIComponent(bookUrl)}`;
        }
        function makeStorageKeyChaptersRead(bookUrl) {
          return `chapters-read-${encodeURIComponent(bookUrl)}`;
        }

        function saveHistory(url) {
          if (!url) return;
          let history = JSON.parse(localStorage.getItem(KEY_HISTORY) || "[]");
          // place most-recent-first, avoid duplicates
          history = history.filter((x) => x !== url);
          history.unshift(url);
          // cap at 30 entries
          history = history.slice(0, 30);
          localStorage.setItem(KEY_HISTORY, JSON.stringify(history));
        }

        function loadHistory() {
          const hist = JSON.parse(localStorage.getItem(KEY_HISTORY) || "[]");
          historyList.innerHTML = "";
          if (!hist.length) {
            historyList.innerHTML = `<div class="history-item muted">Nenhum livro aberto ainda.</div>`;
            historyBrief.textContent = "";
            return;
          }
          hist.forEach((u) => {
            const el = document.createElement("div");
            el.className = "history-item";
            el.textContent = u;
            el.title = u;
            el.onclick = () => {
              book.originalUrl = u;
              book.rawRootUrl = null;
              book.rawBase = null;
              book.tocItems = [];
              bookUrlInput.value = u;
              loadBook();
            };
            historyList.appendChild(el);
          });
          historyBrief.textContent = `${hist.length} livro(s) no histórico`;
        }

        function getReadChapters(bookUrl) {
          return JSON.parse(
            localStorage.getItem(makeStorageKeyChaptersRead(bookUrl)) || "[]"
          );
        }
        function markChapterAsRead(bookUrl, chapterHref) {
          const key = makeStorageKeyChaptersRead(bookUrl);
          const arr = JSON.parse(localStorage.getItem(key) || "[]");
          if (!arr.includes(chapterHref)) {
            arr.push(chapterHref);
            localStorage.setItem(key, JSON.stringify(arr));
          }
        }
        function clearBookMemory(bookUrl) {
          if (!bookUrl) return;
          const keys = Object.keys(localStorage);
          keys.forEach((k) => {
            if (k.includes(encodeURIComponent(bookUrl)))
              localStorage.removeItem(k);
          });
          // also remove last-chapter key which uses encoded book url
          localStorage.removeItem(makeStorageKeyLastChapter(bookUrl));
          localStorage.removeItem(makeStorageKeyChaptersRead(bookUrl));
        }

        function clearAllMemory() {
          localStorage.clear();
        }

        // Render sidebar TOC
        function renderToc() {
          tocList.innerHTML = "";
          if (!book.tocItems || book.tocItems.length === 0) {
            tocList.innerHTML = `<li class="hint muted">Nenhum link encontrado no README.md</li>`;
            tocMeta.textContent = "Sem sumário detectado.";
            return;
          }
          tocMeta.textContent = shorten(
            book.originalUrl || book.rawRootUrl || ""
          );
          const read = getReadChapters(book.originalUrl);
          book.tocItems.forEach((it, idx) => {
            const li = document.createElement("li");
            li.className = "toc-item";
            if (it.href === (activeChapter && activeChapter.href))
              li.classList.add("active");
            if (read.includes(it.href)) li.classList.add("read");

            const dot = document.createElement("div");
            dot.className = "dot";
            dot.style.background = read.includes(it.href)
              ? "linear-gradient(180deg,var(--accent),var(--accent-2))"
              : "rgba(255,255,255,0.06)";
            li.appendChild(dot);

            const title = document.createElement("div");
            title.className = "title";
            title.textContent = it.title;
            li.appendChild(title);

            const actions = document.createElement("div");
            actions.style.display = "flex";
            actions.style.gap = "6px";
            // open icon
            const o = document.createElement("button");
            o.className = "icon-btn";
            o.style.padding = "6px";
            o.title = "Abrir capítulo";
            o.innerHTML = "→";
            o.onclick = (e) => {
              e.stopPropagation();
              openChapterByIndex(idx);
            };
            actions.appendChild(o);

            // mark as unread button
            const m = document.createElement("button");
            m.className = "icon-btn";
            m.style.padding = "6px";
            m.title = "Marcar como não lido";
            m.innerHTML = "⤺";
            m.onclick = (e) => {
              e.stopPropagation();
              // remove from read
              const key = makeStorageKeyChaptersRead(book.originalUrl);
              let arr = JSON.parse(localStorage.getItem(key) || "[]");
              arr = arr.filter((x) => x !== it.href);
              localStorage.setItem(key, JSON.stringify(arr));
              renderToc();
              updateReadCount();
            };
            actions.appendChild(m);

            li.appendChild(actions);

            li.addEventListener("click", () => openChapterByIndex(idx));
            tocList.appendChild(li);
          });
          updateReadCount();
        }

        function updateReadCount() {
          const read = getReadChapters(book.originalUrl);
          readCountEl.textContent =
            read.length + "/" + (book.tocItems ? book.tocItems.length : 0);
        }

        function shorten(url, max = 50) {
          if (!url) return "";
          return url.length > max
            ? url.slice(0, max / 2) + "…" + url.slice(-max / 2)
            : url;
        }

        async function loadBook() {
          const val = bookUrlInput.value.trim();
          if (!val) {
            setStatus("Cole a URL do README.md");
            return;
          }
          setStatus("Convertendo URL e buscando README...");
          try {
            const raw = toRawGithubUrl(val);
            book.originalUrl = val;
            book.rawRootUrl = raw;
            book.rawBase = getRawBase(raw);
            // save history
            saveHistory(val);
            loadHistory();

            const md = await fetchText(raw);
            const items = parseTocFromMarkdown(md);
            // build rawUrl for each
            book.tocItems = items.map((it) => {
              return {
                title: it.title,
                href: it.href,
                rawUrl: buildChapterRawUrl(book.rawBase, it.href),
              };
            });
            renderToc();
            setStatus(`Sumário carregado (${book.tocItems.length})`, 3000);

            // if there is a last chapter saved, open it, else open first
            const lastChapter = localStorage.getItem(
              makeStorageKeyLastChapter(book.originalUrl)
            );
            if (lastChapter) {
              // find matching toc index
              const idx = book.tocItems.findIndex(
                (t) => t.href === lastChapter || t.rawUrl === lastChapter
              );
              if (idx !== -1) openChapterByIndex(idx);
              else {
                // fallback: try to load raw url
                activeChapter = {
                  index: null,
                  title: lastChapter,
                  href: lastChapter,
                  rawUrl: buildChapterRawUrl(book.rawBase, lastChapter),
                };
                await loadAndRenderChapter(activeChapter, true);
              }
            } else if (book.tocItems.length > 0) {
              openChapterByIndex(0);
            }
          } catch (err) {
            console.error(err);
            setStatus(err.message || "Erro ao carregar livro", 5000);
            tocMeta.textContent = "Erro ao carregar.";
          }
        }

        function openChapterByIndex(index) {
          if (!book.tocItems || !book.tocItems[index]) return;
          const it = book.tocItems[index];
          activeChapter = {
            index,
            title: it.title,
            href: it.href,
            rawUrl: it.rawUrl,
          };
          // save last-chapter
          localStorage.setItem(
            makeStorageKeyLastChapter(book.originalUrl),
            it.href
          );
          loadAndRenderChapter(activeChapter);
          renderToc();
        }

        async function loadAndRenderChapter(chapter, silent = false) {
          setStatus("Buscando capítulo...");
          try {
            const md = await fetchText(chapter.rawUrl);
            // convert headings to anchorable ids and build internal toc
            const html = marked.parse(md);
            // sanitize
            const safe = DOMPurify.sanitize(html, { SAFE_FOR_JQUERY: true });
            // parse headings
            const parser = new DOMParser();
            const doc = parser.parseFromString(safe, "text/html");
            // ensure headings have ids
            const headings = Array.from(doc.querySelectorAll("h1,h2,h3"));
            headings.forEach((h) => {
              if (!h.id) {
                const id = h.textContent
                  .trim()
                  .replace(/\s+/g, "-")
                  .replace(/[^\w\-]/g, "")
                  .toLowerCase();
                let uniqueId =
                  id || "h-" + Math.random().toString(36).slice(2, 8);
                // avoid duplicates
                let i = 1;
                while (doc.getElementById(uniqueId)) {
                  uniqueId = id + "-" + i++;
                }
                h.id = uniqueId;
              }
            });

            // serialize back
            const contentHtml = doc.body.innerHTML;

            // render internal TOC (nested)
            const internalTocHtml = buildInternalTocHtml(headings);
            contentEl.innerHTML =
              (internalTocHtml
                ? `<div class="toc-internal" id="tocInternalWrap">${internalTocHtml}</div>`
                : "") + `<div id="chapterContent">${contentHtml}</div>`;

            // after render, restore scroll position (saved per-chapter)
            const key = makeStorageKeyProgress(book.originalUrl, chapter.href);
            const saved = parseInt(localStorage.getItem(key) || "0", 10);
            // small timeout to allow images to load / layout to settle
            requestAnimationFrame(() => {
              if (!isNaN(saved) && saved > 0) reader.scrollTop = saved;
              else reader.scrollTop = 0;
            });

            // Save last-chapter
            localStorage.setItem(
              makeStorageKeyLastChapter(book.originalUrl),
              chapter.href
            );

            // mark as read
            markChapterAsRead(book.originalUrl, chapter.href);
            renderToc();

            // attach link handlers for markdown links
            attachContentLinks();

            // setup heading observer for scrollspy
            setupHeadingObserver();

            // save scroll on reader scroll (debounced)
            attachScrollSaving(key);

            setStatus(`Capítulo: ${chapter.title}`, 3000);
          } catch (err) {
            console.error(err);
            if (!silent) setStatus("Erro ao carregar capítulo", 4000);
          }
        }

        // Build internal TOC HTML (nested by h1>h2>h3)
        function buildInternalTocHtml(headings) {
          if (!headings || headings.length === 0) return "";
          // We'll create a simple nested structure based on heading level
          let html = "<strong>Navegação</strong><ul>";
          let prevLevel = 1;
          headings.forEach((h) => {
            const level = parseInt(h.tagName.substring(1));
            const text = h.textContent.trim();
            const id = h.id;
            html += `<li style="margin-left:${
              (level - 1) * 8
            }px"><a href="#${id}" data-id="${id}">${text}</a></li>`;
            prevLevel = level;
          });
          html += "</ul>";
          return html;
        }

        // attach scroll saving (debounced)
        function attachScrollSaving(key) {
          if (!key) return;
          let t;
          function save() {
            localStorage.setItem(key, String(reader.scrollTop));
          }
          reader.removeEventListener("scroll", reader._saveScrollFn);
          reader._saveScrollFn = function () {
            clearTimeout(t);
            t = setTimeout(save, 150);
          };
          reader.addEventListener("scroll", reader._saveScrollFn);
        }

        function attachContentLinks() {
          // intercept links in chapter content
          const wrap = document.getElementById("chapterContent");
          if (!wrap) return;
          const anchors = wrap.querySelectorAll("a");
          anchors.forEach((a) => {
            const href = a.getAttribute("href") || "";
            if (!href) return;
            // relative .md links or github links -> open in app
            const lower = href.toLowerCase();
            if (
              lower.endsWith(".md") ||
              href.includes("github.com") ||
              href.includes("raw.githubusercontent.com")
            ) {
              a.addEventListener("click", (ev) => {
                ev.preventDefault();
                const raw = buildChapterRawUrl(book.rawBase, href);
                // try to find in toc
                const idx = book.tocItems.findIndex(
                  (t) => t.href === href || t.rawUrl === raw
                );
                if (idx !== -1) openChapterByIndex(idx);
                else {
                  // transient chapter load
                  activeChapter = {
                    index: null,
                    title: href,
                    href,
                    rawUrl: raw,
                  };
                  loadAndRenderChapter(activeChapter);
                }
              });
            } else if (href.startsWith("#")) {
              // smooth scroll within content
              a.addEventListener("click", (ev) => {
                ev.preventDefault();
                const id = a.getAttribute("href").slice(1);
                const target = document.getElementById(id);
                if (target) {
                  target.scrollIntoView({ behavior: "smooth", block: "start" });
                }
              });
            } else {
              // external: open new tab
              a.setAttribute("target", "_blank");
              a.setAttribute("rel", "noopener noreferrer");
            }
          });
          // hook internal TOC links (toc-internal)
          const tocWrap = document.getElementById("tocInternalWrap");
          if (tocWrap) {
            const tlinks = tocWrap.querySelectorAll("a[data-id]");
            tlinks.forEach((a) => {
              a.addEventListener("click", (ev) => {
                ev.preventDefault();
                const id = a.dataset.id;
                const el = document.getElementById(id);
                if (el)
                  el.scrollIntoView({ behavior: "smooth", block: "start" });
              });
            });
          }
        }

        // IntersectionObserver for headings to highlight current
        function setupHeadingObserver() {
          if (headingObserver) headingObserver.disconnect();
          const root = reader;
          const options = {
            root,
            rootMargin: "0px 0px -60% 0px",
            threshold: 0,
          };
          headingObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const id = entry.target.id;
                if (!id) return;
                // highlight internal toc link
                const tocWrap = document.getElementById("tocInternalWrap");
                if (tocWrap) {
                  const links = tocWrap.querySelectorAll("a[data-id]");
                  links.forEach((a) =>
                    a.classList.toggle("active", a.dataset.id === id)
                  );
                }
                currentHeadingId = id;
              }
            });
          }, options);

          // observe h1-h3 in chapterContent
          const wrap = document.getElementById("chapterContent");
          if (!wrap) return;
          const headings = wrap.querySelectorAll("h1,h2,h3");
          headings.forEach((h) => headingObserver.observe(h));
        }

        // UI controls
        collapseTocBtn.addEventListener("click", () => {
          tocPane.classList.toggle("hidden");
        });
        toggleTocBtn.addEventListener("click", () => {
          tocPane.classList.toggle("hidden");
        });
        toggleFullscreenToc.addEventListener("click", () => {
          // toggle fullscreen: hide sidebar if visible, or show if hidden
          tocPane.classList.toggle("hidden");
        });
        refreshTocBtn.addEventListener("click", () => {
          if (book.rawRootUrl) loadBook();
        });

        clearBookBtn.addEventListener("click", () => {
          if (!book.originalUrl) {
            alert("Nenhum livro carregado.");
            return;
          }
          if (
            !confirm(
              "Limpar todos os dados deste livro (progresso, capítulos lidos, último capítulo)?"
            )
          )
            return;
          clearBookMemory(book.originalUrl);
          renderToc();
          loadHistory();
          setStatus("Memória do livro limpa.", 2500);
        });
        clearAllBtn.addEventListener("click", () => {
          if (
            !confirm("Limpar TODOS os dados do leitor (histórico e progresso)?")
          )
            return;
          clearAllMemory();
          renderToc();
          loadHistory();
          setStatus("Memória geral limpa.", 2500);
        });

        // open chapter by index helper
        function openChapterIndexIfExists(rawUrl) {
          const idx = book.tocItems.findIndex(
            (t) => t.rawUrl === rawUrl || t.href === rawUrl
          );
          if (idx !== -1) openChapterByIndex(idx);
        }

        // open by index
        function openChapterByIndex(idx) {
          if (!book.tocItems[idx]) return;
          activeChapter = {
            index: idx,
            title: book.tocItems[idx].title,
            href: book.tocItems[idx].href,
            rawUrl: book.tocItems[idx].rawUrl,
          };
          // save last chapter for this book
          localStorage.setItem(
            makeStorageKeyLastChapter(book.originalUrl),
            activeChapter.href
          );
          loadAndRenderChapter(activeChapter);
          renderToc();
        }

        // wire load button and Enter key
        loadBtn.addEventListener("click", () => {
          loadBook();
        });
        bookUrlInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") loadBook();
        });

        // initial load: history and optional last used
        loadHistory();

        // If user had a last-used book (most recent in history), prefill input
        (function prefillLast() {
          const hist = JSON.parse(localStorage.getItem(KEY_HISTORY) || "[]");
          if (hist.length) {
            bookUrlInput.value = hist[0];
            // do not auto-load to avoid network call without consent
            // but we can optionally auto-load; currently we leave it to user
          }
        })();

        // Helper: convert GitHub raw for build function external uses
        function toRawGithubUrl(input) {
          try {
            // reuse toRawGithubUrl from outer - if exists, call; else use basic convert
            return window.URL
              ? (function () {
                  const u = new URL(input);
                  if (u.hostname === "raw.githubusercontent.com") return input;
                  if (u.hostname === "github.com") {
                    return input
                      .replace(
                        "https://github.com/",
                        "https://raw.githubusercontent.com/"
                      )
                      .replace("/blob/", "/");
                  }
                  throw new Error("URL inválida");
                })()
              : input;
          } catch (e) {
            throw e;
          }
        }

        // Expose some utils for debugging
        window.MDReader = {
          loadBook,
          loadAndRenderChapter,
          toRawGithubUrl,
          buildChapterRawUrl,
        };
      })();
    </script>
  </body>
</html>
